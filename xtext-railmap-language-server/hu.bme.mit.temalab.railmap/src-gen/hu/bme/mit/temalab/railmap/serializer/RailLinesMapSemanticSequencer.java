/*
 * generated by Xtext 2.20.0-SNAPSHOT
 */
package hu.bme.mit.temalab.railmap.serializer;

import com.google.inject.Inject;
import hu.bme.mit.temalab.railmap.railLinesMap.Connection;
import hu.bme.mit.temalab.railmap.railLinesMap.RailLineMap;
import hu.bme.mit.temalab.railmap.railLinesMap.RailLinesMapPackage;
import hu.bme.mit.temalab.railmap.railLinesMap.Station;
import hu.bme.mit.temalab.railmap.railLinesMap.StationTrackLocation;
import hu.bme.mit.temalab.railmap.railLinesMap.Turnout;
import hu.bme.mit.temalab.railmap.railLinesMap.TurnoutEndLocation;
import hu.bme.mit.temalab.railmap.services.RailLinesMapGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class RailLinesMapSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RailLinesMapGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RailLinesMapPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RailLinesMapPackage.CONNECTION:
				sequence_Connection(context, (Connection) semanticObject); 
				return; 
			case RailLinesMapPackage.RAIL_LINE_MAP:
				sequence_RailLineMap(context, (RailLineMap) semanticObject); 
				return; 
			case RailLinesMapPackage.STATION:
				sequence_Station(context, (Station) semanticObject); 
				return; 
			case RailLinesMapPackage.STATION_TRACK_LOCATION:
				sequence_StationTrackLocation(context, (StationTrackLocation) semanticObject); 
				return; 
			case RailLinesMapPackage.TURNOUT:
				sequence_Turnout(context, (Turnout) semanticObject); 
				return; 
			case RailLinesMapPackage.TURNOUT_END_LOCATION:
				sequence_TurnoutEndLocation(context, (TurnoutEndLocation) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Connection returns Connection
	 *
	 * Constraint:
	 *     (src=Location dst=Location length=INT gauge=Gauge?)
	 */
	protected void sequence_Connection(ISerializationContext context, Connection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RailLineMap returns RailLineMap
	 *
	 * Constraint:
	 *     (mapName=STRING (stations+=Station | turnouts+=Turnout | connections+=Connection)*)
	 */
	protected void sequence_RailLineMap(ISerializationContext context, RailLineMap semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Location returns StationTrackLocation
	 *     StationTrackLocation returns StationTrackLocation
	 *
	 * Constraint:
	 *     (station=[Station|ID] track=INT)
	 */
	protected void sequence_StationTrackLocation(ISerializationContext context, StationTrackLocation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RailLinesMapPackage.Literals.STATION_TRACK_LOCATION__STATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RailLinesMapPackage.Literals.STATION_TRACK_LOCATION__STATION));
			if (transientValues.isValueTransient(semanticObject, RailLinesMapPackage.Literals.STATION_TRACK_LOCATION__TRACK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RailLinesMapPackage.Literals.STATION_TRACK_LOCATION__TRACK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStationTrackLocationAccess().getStationStationIDTerminalRuleCall_0_0_1(), semanticObject.eGet(RailLinesMapPackage.Literals.STATION_TRACK_LOCATION__STATION, false));
		feeder.accept(grammarAccess.getStationTrackLocationAccess().getTrackINTTerminalRuleCall_2_0(), semanticObject.getTrack());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Station returns Station
	 *
	 * Constraint:
	 *     (name=ID tracks=INT?)
	 */
	protected void sequence_Station(ISerializationContext context, Station semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Location returns TurnoutEndLocation
	 *     TurnoutEndLocation returns TurnoutEndLocation
	 *
	 * Constraint:
	 *     (turnout=[Turnout|ID] end=TurnoutEnd)
	 */
	protected void sequence_TurnoutEndLocation(ISerializationContext context, TurnoutEndLocation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RailLinesMapPackage.Literals.TURNOUT_END_LOCATION__TURNOUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RailLinesMapPackage.Literals.TURNOUT_END_LOCATION__TURNOUT));
			if (transientValues.isValueTransient(semanticObject, RailLinesMapPackage.Literals.TURNOUT_END_LOCATION__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RailLinesMapPackage.Literals.TURNOUT_END_LOCATION__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTurnoutEndLocationAccess().getTurnoutTurnoutIDTerminalRuleCall_0_0_1(), semanticObject.eGet(RailLinesMapPackage.Literals.TURNOUT_END_LOCATION__TURNOUT, false));
		feeder.accept(grammarAccess.getTurnoutEndLocationAccess().getEndTurnoutEndEnumRuleCall_2_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Turnout returns Turnout
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Turnout(ISerializationContext context, Turnout semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RailLinesMapPackage.Literals.TURNOUT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RailLinesMapPackage.Literals.TURNOUT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTurnoutAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
